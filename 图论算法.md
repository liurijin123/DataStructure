# 一、概念
+ 图(graph)：G(V,E)由顶点(vertex)的集V和边(edge)的集E组成。
+ 边(edge)：每一条边就是一幅点对(v,w)，其中v,w属于V
+ 有向图：如果点对是有序的，那么图就是有向图
+ 邻接：两个顶点相邻
+ 权(weight)：边上的属性值
+ 值(cost)：顶点上的属性值
+ 路径(path)：顶点的序列
+ 长(length)：路径上的边数
+ 简单路径：路径上所有顶点都是互异的
+ 连通的：无向图中每个顶点到其他顶点都存在一条路径
+ 强连通的：有向图中每个顶点到其他顶点都存在一条路径
+ 弱连通的：非强连通有向图的基础图是连通的，则该有向图是弱连通的
+ 完全图：每一对顶点间都存在一条边的图
# 二、图的表示
## 1.邻接矩阵
>对于每条边(u,v)，置A[u][v]等于true；否则等于false。如果边有权，则等于权
+ 优点：非常简单
+ 缺点：空间需求大

![](https://github.com/liurijin123/picture/blob/master/1005320-20161115153351529-548277748.png)
## 2.邻接表
>对每个顶点，使用一个表存放所有邻接的顶点

![](https://images2015.cnblogs.com/blog/1005320/201611/1005320-20161115153921029-1972544191.png)
# 三、拓扑排序
>拓扑排序是对有向无圈图的顶点的一种排序，使得如果存在一条从Vi到Vj的路径，那么在排序中Vj就出现在Vi的后面。
## 1.入度表
+ 找出图中0入度的顶点；
+ 依次在图中删除这些顶点，删除后再找出0入度的顶点；
+ 然后再删除……再找出……
+ 直至删除所有顶点，即完成拓扑排序
## 2.深度优先搜索
在DFS中，依次打印所遍历到的顶点；而在拓扑排序时，顶点必须比其邻接点先出现。在下图中，顶点5比顶点0先出现，顶点4比顶点1先出现。

![](https://images2015.cnblogs.com/blog/399159/201512/399159-20151229144507870-1351373142.png)

在DFS实现拓扑排序时，用栈来保存拓扑排序的顶点序列；并且保证在某顶点入栈前，其所有邻接点已入栈。
# 四、最短路径算法
## 1.无权最短路径
>广度优先遍历。该方法按层处理顶点：距离最近的顶点首先被赋值，然后最远的点最后被赋值。
## 2.有权最短路径(Dijkstra算法)
+ 算法特点：

迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。
+ 算法的思路

Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 
然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 

然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。

然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。
## 3.具有负值的图
# 五、生成最小树
## 1.Prim算法
算法描述

1).输入：一个加权连通图，其中顶点集合为V，边集合为E；

2).初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空；

3).重复下列操作，直到Vnew = V：

   a.在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；
   
   b.将v加入集合Vnew中，将<u, v>边加入集合Enew中；
   
4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。
## 2.Kruskal算法
算法描述

1）新建图G，G中拥有原图中相同的节点，但没有边；

2）将原图中所有的边按权值从小到大排序；

3）从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中；

4）重复3，直至图G中所有的节点都在同一个连通分量中。
# 六、深度优先搜索算法
它从图中某个结点v出发，访问此顶点，然后从v的未被访问的邻接点出发深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中的所有顶点都被访问到为止。

基本实现思想：

（1）访问顶点v；

（2）从v的未被访问的邻接点中选取一个顶点w，从w出发进行深度优先遍历；

（3）重复上述两步，直至图中所有和v有路径相通的顶点都被访问到。

 

递归实现

（1）访问顶点v；visited[v]=1；//算法执行前visited[n]=0

（2）w=顶点v的第一个邻接点；

（3）while（w存在）

if（w未被访问）

从顶点w出发递归执行该算法；
w=顶点v的下一个邻接点；

 

非递归实现

（1）栈S初始化；visited[n]=0；

（2）访问顶点v；visited[v]=1；顶点v入栈S

（3）while(栈S非空)

x=栈S的顶元素(不出栈)；

if(存在并找到未被访问的x的邻接点w)

访问w；visited[w]=1；

w进栈;

else

x出栈；

# 七、广度优先搜索算法
它是一个分层搜索的过程和二叉树的层次遍历十分相似，它也需要一个队列以保持遍历过的顶点顺序，以便按出队的顺序再去访问这些顶点的邻接顶点。

 

基本实现思想：

（1）顶点v入队列。

（2）当队列非空时则继续执行，否则算法结束。

（3）出队列取得队头顶点v；访问顶点v并标记顶点v已被访问。

（4）查找顶点v的第一个邻接顶点col。

（5）若v的邻接顶点col未被访问过的，则col入队列。

（6）继续查找顶点v的另一个新的邻接顶点col，转到步骤（5）。

直到顶点v的所有未被访问过的邻接点处理完。转到步骤（2）。

广度优先遍历图是以顶点v为起始点，由近至远，依次访问和v有路径相通而且路径长度为1，2，……的顶点。为了使“先被访问顶点的邻接点”先于“后被访问顶点的邻接点”被访问，需设置队列存储访问的顶点。


伪代码

（1）初始化队列Q；visited[n]=0；

（2）访问顶点v；visited[v]=1；顶点v入队列Q；

（3） while（队列Q非空）

v=队列Q的对头元素出队；

w=顶点v的第一个邻接点；

while（w存在）

如果w未访问，则访问顶点w；

visited[w]=1；

顶点w入队列Q；

w=顶点v的下一个邻接点。
