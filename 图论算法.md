# 一、概念
+ 图(graph)：G(V,E)由顶点(vertex)的集V和边(edge)的集E组成。
+ 边(edge)：每一条边就是一幅点对(v,w)，其中v,w属于V
+ 有向图：如果点对是有序的，那么图就是有向图
+ 邻接：两个顶点相邻
+ 权(weight)：边上的属性值
+ 值(cost)：顶点上的属性值
+ 路径(path)：顶点的序列
+ 长(length)：路径上的边数
+ 简单路径：路径上所有顶点都是互异的
+ 连通的：无向图中每个顶点到其他顶点都存在一条路径
+ 强连通的：有向图中每个顶点到其他顶点都存在一条路径
+ 弱连通的：非强连通有向图的基础图是连通的，则该有向图是弱连通的
+ 完全图：每一对顶点间都存在一条边的图
# 二、图的表示
## 1.邻接矩阵
>对于每条边(u,v)，置A[u][v]等于true；否则等于false。如果边有权，则等于权
+ 优点：非常简单
+ 缺点：空间需求大

![](https://github.com/liurijin123/picture/blob/master/1005320-20161115153351529-548277748.png)
## 2.邻接表
>对每个顶点，使用一个表存放所有邻接的顶点

![](https://images2015.cnblogs.com/blog/1005320/201611/1005320-20161115153921029-1972544191.png)
# 三、拓扑排序
>拓扑排序是对有向无圈图的顶点的一种排序，使得如果存在一条从Vi到Vj的路径，那么在排序中Vj就出现在Vi的后面。
## 1.入度表
+ 找出图中0入度的顶点；
+ 依次在图中删除这些顶点，删除后再找出0入度的顶点；
+ 然后再删除……再找出……
+ 直至删除所有顶点，即完成拓扑排序
## 2.深度优先搜索
在DFS中，依次打印所遍历到的顶点；而在拓扑排序时，顶点必须比其邻接点先出现。在下图中，顶点5比顶点0先出现，顶点4比顶点1先出现。

![](https://images2015.cnblogs.com/blog/399159/201512/399159-20151229144507870-1351373142.png)

在DFS实现拓扑排序时，用栈来保存拓扑排序的顶点序列；并且保证在某顶点入栈前，其所有邻接点已入栈。
# 四、最短路径算法
## 1.无权最短路径
>广度优先遍历。该方法按层处理顶点：距离最近的顶点首先被赋值，然后最远的点最后被赋值。
## 2.有权最短路径(Dijkstra算法)
+ 算法特点：

迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。
+ 算法的思路

Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。 
然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点， 

然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。

然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。
## 3.具有负值的图
# 五、生成最小树
## 1.Prim算法
算法描述

1).输入：一个加权连通图，其中顶点集合为V，边集合为E；

2).初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空；

3).重复下列操作，直到Vnew = V：

   a.在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；
   
   b.将v加入集合Vnew中，将<u, v>边加入集合Enew中；
   
4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。
## 2.Kruskal算法
算法描述

1）新建图G，G中拥有原图中相同的节点，但没有边；

2）将原图中所有的边按权值从小到大排序；

3）从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中；

4）重复3，直至图G中所有的节点都在同一个连通分量中。
# 六、深度优先搜索算法
算法描述

1）访问指定的起始顶点；

2）若当前访问的顶点的邻接顶点有未被访问的，则任选一个访问之；反之，退回到最近访问过的顶点；直到与起始顶点相通的全部顶点都访问完毕；

3）若此时图中尚有顶点未被访问，则再选其中一个顶点作为起始顶点并访问之，转 2； 反之，遍历结束。

# 七、广度优先搜索算法
算法描述

类似树的层序遍历
